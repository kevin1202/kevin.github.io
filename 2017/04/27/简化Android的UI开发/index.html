
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>简化Android的UI开发 | Kevin博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Kevin">
    

    
    <meta name="description" content="原文链接 : android ui development made easy

如果你觉得这篇文章太长，而且还没有往下阅读的话，我可以给你简要的介绍文章要讲的内容：我使用纯 Java 通过数据绑定的方式提供了一种
Android UI 开发的代码往往是支离破碎的，写出来的代码通常都是大量的模板化代码，而且没有结构可言。下面是一些问题（纯属个人见解）：

Android UI 开发很少符合 MV">
<meta property="og:type" content="article">
<meta property="og:title" content="简化Android的UI开发">
<meta property="og:url" content="https://kevin1202.github.io/2017/04/27/简化Android的UI开发/index.html">
<meta property="og:site_name" content="Kevin博客">
<meta property="og:description" content="原文链接 : android ui development made easy

如果你觉得这篇文章太长，而且还没有往下阅读的话，我可以给你简要的介绍文章要讲的内容：我使用纯 Java 通过数据绑定的方式提供了一种
Android UI 开发的代码往往是支离破碎的，写出来的代码通常都是大量的模板化代码，而且没有结构可言。下面是一些问题（纯属个人见解）：

Android UI 开发很少符合 MV">
<meta property="og:updated_time" content="2017-04-28T03:44:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="简化Android的UI开发">
<meta name="twitter:description" content="原文链接 : android ui development made easy

如果你觉得这篇文章太长，而且还没有往下阅读的话，我可以给你简要的介绍文章要讲的内容：我使用纯 Java 通过数据绑定的方式提供了一种
Android UI 开发的代码往往是支离破碎的，写出来的代码通常都是大量的模板化代码，而且没有结构可言。下面是一些问题（纯属个人见解）：

Android UI 开发很少符合 MV">

    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="Kevin博客" title="Kevin博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Kevin博客">Kevin博客</a></h1>
				<h2 class="blog-motto">梦想还是要有的，万一实现了呢？</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
						<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" class="st-default-search-input" maxlength="20" placeholder="Search" />
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/27/简化Android的UI开发/" title="简化Android的UI开发" itemprop="url">简化Android的UI开发</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kevin" target="_blank" itemprop="author">Kevin</a>
		
  <p class="article-time">
    <time datetime="2017-04-27T10:28:07.000Z" itemprop="datePublished"> 发表于 2017-04-27</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-mithril-js-建立用户接口"><span class="toc-number">1.</span> <span class="toc-text">使用 mithril.js 建立用户接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟布局"><span class="toc-number">2.</span> <span class="toc-text">虚拟布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#那么，我们要怎么去渲染呢？"><span class="toc-number">3.</span> <span class="toc-text">那么，我们要怎么去渲染呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么时候去渲染呢？"><span class="toc-number">4.</span> <span class="toc-text">什么时候去渲染呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总的来说"><span class="toc-number">5.</span> <span class="toc-text">总的来说</span></a></li></ol>
		
		</div>
		
		<ul>
<li>原文链接 : <a href="http://zserge.com/blog/android-mvx.html" target="_blank" rel="external">android ui development made easy</a></li>
</ul>
<p>如果你觉得这篇文章太长，而且还没有往下阅读的话，我可以给你简要的介绍文章要讲的内容：我使用纯 Java 通过数据绑定的方式提供了一种</p>
<p>Android UI 开发的代码往往是支离破碎的，写出来的代码通常都是大量的模板化代码，而且没有结构可言。下面是一些问题（纯属个人见解）：</p>
<ul>
<li><p>Android UI 开发很少符合 MVC 模式（或者是 M-V-其他任何东西）</p>
</li>
<li><p>XML文件通常包含了很多重复的代码，在代码复用方面比较糟糕</p>
</li>
<li><p>XMLS 非常脆弱，这使得你在写 XML 文件时，即使输入了 TextVeiw ，在编译过程中编译器也不会警告你，但在 App 运行时又会抛出 InflateException 异常</p>
</li>
<li><p>缺少对 styles 的支持，缺少对变量的支持，不支持宏和计算结果（例如 10dp + 2px)</p>
</li>
<li><p>没有数据绑定，这使得你必须自己把所有的 findViewById 和 setOn…Listener 写好</p>
</li>
<li><p>你可以通过 Java 实现你的布局，但是写出来的代码有如天书</p>
</li>
</ul>
<h2 id="使用-mithril-js-建立用户接口"><a href="#使用-mithril-js-建立用户接口" class="headerlink" title="使用 mithril.js 建立用户接口"></a>使用 mithril.js 建立用户接口</h2><p>在 Web 开发中，开发者们很快就意识到在没有 MVx 的情况下开发复杂的应用会很吃力，这使得他们意识到 jQuery 中存在的问题，并开发了 Backbone，Knockout，Angular，Ember…等等，来提高他们的开发效率</p>
<p>但在 Android 中，我们还在通过那一点点函数毫无章法可言地设置 View 的属性，就像在 jQuery 里一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'.myview'</span>).text(<span class="string">'Hello'</span>);</div><div class="line">$(<span class="string">'.myview'</span>).on(<span class="string">'click'</span>, function() &#123;</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line">myView.setText(<span class="string">"Hello"</span>);</div><div class="line">myView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123; ...&#125;);</div></pre></td></tr></table></figure>
<p>我们在一个目录下定义了我们的 Layout ，又在另一个目录中使用它们，然后在 UI 开发的代码里改变<br>，这样并不好。</p>
<p>React.js 对 Web 开发有一点点影响：他们以树状关系的自定义对象创建了一个虚拟的 DOM 概念，并以此展示实际的 HTML 布局。虚拟树创建和切换的时间都很短，所以当实际的 DOM 需要被渲染，两棵虚拟树（前一棵和新的那棵）将进行对比，只有不匹配的部分才会被渲染。</p>
<p>Mithril.js 是一个精悍、短小的框架，使用它能使 React.js 的实现更整洁。在 Mithril 中，除了纯 JavaScript，你几乎能摆脱一切，同时，它还能让你在写布局的时候感受到图灵完备的语言所具备的力量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> m(<span class="string">'div'</span>,</div><div class="line">         m(<span class="string">'p'</span>, someText),</div><div class="line">         m(<span class="string">'ul'</span>,</div><div class="line">           items.map((item) =&gt; m(<span class="string">'li'</span>, item))),</div><div class="line">         m(<span class="string">'button'</span>, &#123;onclick: myClickHandler&#125;));</div></pre></td></tr></table></figure>
<p>因此，你能用循环生成许多 View，你能用判断语句改变布局中的某个部分，最后你能绑定数据和设置事件监听器。</p>
<p>那这个方法能在 Android 中被使用吗？</p>
<h2 id="虚拟布局"><a href="#虚拟布局" class="headerlink" title="虚拟布局"></a>虚拟布局</h2><p>虚拟布局（使用类似 Web 中虚拟 DOM 的概念）是树状的自定义Java对象集合，被用于展示实际的 Android 布局。虽然 App 的数据改变多少次，树就会被构建多少次，但布局改变的内容应该仅仅是前后不一致的部分（当前的布局和改变前布局）。</p>
<p>我们的框架只导入一个静态类，所以所有类中的静态方法都不需要类名前缀就能被使用（例如我们只需要使用 v()，而不是 Render.v()），这是语言特性带来的好处。下面是我们如何创建布局的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">v(LinearLayout.class,</div><div class="line">    orientation(LinearLayout.VERTICAL),</div><div class="line">    v(TextView.class,</div><div class="line">        text(someText)),</div><div class="line">    v(Button.class,</div><div class="line">        text(<span class="string">"Click me"</span>),</div><div class="line">        onClick(someClickHandler)));</div></pre></td></tr></table></figure>
<p>第一个 v() 方法返回了一个虚拟布局，每一次调用后它会返回当前应用状态的实际展示（不是实际的 View！）</p>
<p>当一些文字变量被改变 - 虚拟树会获得一个被用于下次渲染的发生了改变的结点值，然后调用 setText()改变相应的 TextView 实例。但是其余的布局不会发生任何变化。</p>
<p>一棵虚拟布局树在理想情况下应该只是一个类，我们就把它叫作结点吧。但是结点主要有两种类型：View 结点（TextView.class等等）和属性设置结点，例如text（someText)</p>
<p>那这就意味着结点应该任意包含一个 View 类和一个方法去改变 View 的属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AttributeSetter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(View v)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">    List&lt;Node&gt; attrs = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</div><div class="line">    Class&lt;? extends View&gt; viewClass; <span class="comment">// for view nodes</span></div><div class="line">    AttributeSetter setter;          <span class="comment">// for attribute setter nodes</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Class&lt;? extends View&gt; c)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.viewClass = c;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(AttributeSetter setter)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.setter = setter;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们需要定义类在产生虚拟布局的时候实际能干的事情了，那就让我们来调用可渲染类吧。一个可渲染类可以是一个 Activity，或者一个自定义的 ViewGroup，或者 Fragment 也凑合。每一个可渲染类都应该有一个用于返回虚拟布局的方法，此外，如果这个方法指定了它将要作用于实际布局中的哪个 View 会更好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Renderable</span> </span>&#123;</div><div class="line">    <span class="function">Node <span class="title">view</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">ViewGroup <span class="title">getRootView</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于 v() 方法的第一个参数是 View 子类的泛型，所以你不用担心类型安全问题。剩下的参数都是结点类型，所以我们只需要把它们添加到 list 中，无视掉空结点的话效果会更好一些。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">v</span><span class="params">(<span class="keyword">final</span> Class&lt;? extends View&gt; cls, <span class="keyword">final</span> Node ...nodes)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(cls) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Here’s an example of the text() attribute setter (the real code is a bit different, but it could have been implemented like this):</p>
<p>下面是一个 text() 属性的设置方法（实际代码会有点不一样，但是也能像下面这样实现）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">text</span><span class="params">(<span class="keyword">final</span> String s)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="keyword">new</span> AttributeSetter() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">            ((TextView) v).setText(s);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其他类似的工具方法也能用于改变线性布局的方向，View 的大小、页边距、间距，总之所有 View 的参数都能被改变。</p>
<h2 id="那么，我们要怎么去渲染呢？"><a href="#那么，我们要怎么去渲染呢？" class="headerlink" title="那么，我们要怎么去渲染呢？"></a>那么，我们要怎么去渲染呢？</h2><p>现在我们需要一个“渲染者”。这是一个能够根据类名创建 View ，使用 AttributeSetters修改对应的参数并且递归地添加子 View的方法。（同样的，下面的代码也是被简化的，实际的代码会有些不一样，主要差别在于当结点没有被改变的时候，我们应该如何避免视图的渲染）<br>​<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> View <span class="title">inflateNode</span><span class="params">(Context c, Node node, ViewGroup parent)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (node.viewClass == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Root is not a view!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Exception handling skipped here to make the code look shorter</span></div><div class="line">    View v = (View) node.viewClass.getConstructor(Context.class).newInstance(c);</div><div class="line">    parent.addView(v);</div><div class="line">    <span class="keyword">for</span> (Node subnode: node.attrs) &#123;</div><div class="line">        <span class="keyword">if</span> (subnode.setter != <span class="keyword">null</span>) &#123;</div><div class="line">            subnode.setter.set(v);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            View subview = inflateNode(c, subnode, (ViewGroup) v);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> v;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们真的可以摆脱 XMLS，并以一种简洁的方式通过 Java 进行布局了。</p>
<p>布局结点不应该直接地被使用，而应该是通过 render(Renderer r) 和 render()被使用。前者用于重渲染某一个 View，后者用于重渲染所有被展示的 View。Renderer 通过一个弱哈希表存储，使得在 View 被移除或者 Activity 被销毁的同时 - 他们的渲染者也不会再被使用。</p>
<h2 id="什么时候去渲染呢？"><a href="#什么时候去渲染呢？" class="headerlink" title="什么时候去渲染呢？"></a>什么时候去渲染呢？</h2><p>这个框架的核心在于 自动进行重渲染，使得 UI 总能展示当前的虚拟布局状态。这就意味着 render() 应该在某个特定的节点被调用。</p>
<p>我参考 Mithril 的方法，把每一个 On…Listener 和 调用 render 的方法捆绑在每一次 UI 的交互中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">onClick</span><span class="params">(<span class="keyword">final</span> View.OnClickListener listener)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="keyword">new</span> AttributeSetter() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">            v.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                    listener.onClick(v);</div><div class="line">                    <span class="comment">// After the click was processed - some data may have been changed</span></div><div class="line">                    <span class="comment">// so we try to re-render the UI</span></div><div class="line">                    render();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我觉得这样做是有道理的，因为大多数 Android 应用的数据都是在发生用户交互的时候被改变的。如果你的数据是因为其他因素被改变的 - 那就只能手动通过 render()渲染了。</p>
<h2 id="总的来说"><a href="#总的来说" class="headerlink" title="总的来说"></a>总的来说</h2><p>这个方法虽然简单，却非常有用：</p>
<ul>
<li><p>你能用类似 XML 的方式定义你的布局结构（通过嵌套调用 v() 方法）</p>
</li>
<li><p>你能用一种清晰易懂的方式绑定数据和监听器</p>
</li>
<li><p>布局都是类型安全的，并且你的编译器会自动完成相应的工作</p>
</li>
<li><p>没有运行时产生的开销，没有使用反射机制，没有自动生成代码</p>
</li>
<li><p>你能在任何地方使用 Java（变量，语句，宏）生成布局</p>
</li>
<li><p>你能用自定义 View 和自定义的属性设置方法</p>
</li>
<li><p>因为你的所有 UI 数据都被保存在属性中，因此你能轻易的保存它们</p>
</li>
<li><p>使用纯 Java 实现这些逻辑需要的代码还不到 250 行！</p>
</li>
</ul>
<p>以上证明了这个方法是可行的。现在我在想，如果有人想要用这个方法开发一个功能齐全的库呢？</p>
<p>设计一个好的“区分”算法会是其中的关键。基本地，它应该能判断一个结点是否被添加/移除/修改，而文件就在于属性节点。简单的数据类型我们只要调用 equals() 去比较两个值就可以了，但是监听器呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">v(SomeView.java,</div><div class="line">    onClick(v =&gt; ...));</div></pre></td></tr></table></figure>
<p>这样做的话每一次虚拟树被创建，都会创建一个对应的监听器对象。那怎么去比较它们？还是永远都不更新监听器，只更新发生了改变的监听器类？或者使用某种事件分发机制分发事件，而不是使用监听器？</p>
<p>另一件需要被注意的是：我不想自己把所有属性设置方法写好。这里有一个更好的方法，也就是 Kotlin 他们在 koan 库中做的那样。</p>
<p>我现在在研究怎么从 android.jar 的类中自动生成设置器，以使得这个项目更有用。</p>
<p>不管怎样，现在的代码我都放在 <a href="https://github.com/zserge/anvil" target="_blank" rel="external">Github</a> 上了，有 MIT 的许可。欢迎大家来评论和 PR！</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://kevin1202.github.io/2017/04/27/简化Android的UI开发/" data-title="简化Android的UI开发 | Kevin博客" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2017/04/27/Service测试/" title="Service测试">
  <strong>上一篇：</strong><br/>
  <span>
  Service测试</span>
</a>
</div>


<div class="next">
<a href="/2017/04/27/NotRxJava懒人专用指南/"  title="NotRxJava懒人专用指南">
 <strong>下一篇：</strong><br/> 
 <span>NotRxJava懒人专用指南
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2017/04/27/简化Android的UI开发/" data-title="简化Android的UI开发" data-url="https://kevin1202.github.io/2017/04/27/简化Android的UI开发/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-mithril-js-建立用户接口"><span class="toc-number">1.</span> <span class="toc-text">使用 mithril.js 建立用户接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟布局"><span class="toc-number">2.</span> <span class="toc-text">虚拟布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#那么，我们要怎么去渲染呢？"><span class="toc-number">3.</span> <span class="toc-text">那么，我们要怎么去渲染呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么时候去渲染呢？"><span class="toc-number">4.</span> <span class="toc-text">什么时候去渲染呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总的来说"><span class="toc-number">5.</span> <span class="toc-text">总的来说</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="kevin1202" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Android/" title="Android">Android<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/git/" title="git">git<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/mac/" title="mac">mac<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Mac/" title="Mac">Mac<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Library/" title="Library">Library<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Spannable/" title="Spannable">Spannable<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/TimerTask/" title="TimerTask">TimerTask<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Timer/" title="Timer">Timer<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/size/" title="size">size<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Travis-CI/" title="Travis-CI">Travis-CI<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 每天进步一点，就是要付诸行动。光有进步一点的想法，而不付诸行动，那么这种想  <br/>
			法只是空想，是永远也不会有进步的。”路行之而成”，路是人走出来的；进步也是人 </p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/5052645262" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/kevin1202" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:yangkai1202@126.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="Kevin">Kevin</a>
		
		
		</p>
		<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','DBjSFU5kGEcv8E-m-m_m','2.0.0');
</script>
</div></footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"kevinbolg"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?575e1640d293c4bdc82c5d203e895c4f";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
