
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Kevin博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Kevin">
    

    
    <meta name="description" content="欢迎大家来到我的博客，希望可以帮到你们，很高兴认识你们。我的github地址：https:github.com/kevin1202">
<meta property="og:type" content="website">
<meta property="og:title" content="Kevin博客">
<meta property="og:url" content="https://kevin1202.github.io/index.html">
<meta property="og:site_name" content="Kevin博客">
<meta property="og:description" content="欢迎大家来到我的博客，希望可以帮到你们，很高兴认识你们。我的github地址：https:github.com/kevin1202">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kevin博客">
<meta name="twitter:description" content="欢迎大家来到我的博客，希望可以帮到你们，很高兴认识你们。我的github地址：https:github.com/kevin1202">

    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="Kevin博客" title="Kevin博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Kevin博客">Kevin博客</a></h1>
				<h2 class="blog-motto">梦想还是要有的，万一实现了呢？</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
						<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" class="st-default-search-input" maxlength="20" placeholder="Search" />
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/27/深入理解Shared-Element-Transition/" title="深入理解 Shared Element Transition" itemprop="url">深入理解 Shared Element Transition</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kevin" target="_blank" itemprop="author">Kevin</a>
		
  <p class="article-time">
    <time datetime="2017-04-27T10:28:07.000Z" itemprop="datePublished"> 发表于 2017-04-27</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>这篇文章会深度分析共享元素 transitions 和它在 Activity &amp; Fragment Transitions API 中的作用。这篇文章是下面这个系列中的第三篇</p>
<ul>
<li>Part 1 <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-transitions-in-android-lollipop-part1.html" target="_blank" rel="external">在 Activity 和 Fragment 中使用 Transition </a></li>
<li>Part 2 <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-content-transitions-in-depth-part2.html" target="_blank" rel="external">深入理解 Content Transition</a></li>
<li>Part 3a <a href="http://www.androiddesignpatterns.com/2015/01/activity-fragment-shared-element-transitions-in-depth-part3a.html" target="_blank" rel="external">深入理解共享元素 Transition</a></li>
<li>Part 3b <a href="http://www.androiddesignpatterns.com/2015/03/activity-postponed-shared-element-transitions-part3b.html" target="_blank" rel="external">延迟共享元素的 Transition</a></li>
<li>Part 3c 共享元素回调实践 (coming soon!)</li>
<li>Part 4  Activity &amp; Fragment 过渡动画示例(coming soon!)</li>
</ul>
<p>Part 3 会分成三个部分: part3a 介绍 共享元素 transitions 的底层操作，part3b 和 part3c<br>主要关注 API 的具体实现细节，例如推迟某些 共享元素 transition 的重要性和如何实现<br>SharedElementCallbacks。</p>
<p>我们首先会总结下在 <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-transitions-in-android-lollipop-part1.html" target="_blank" rel="external">part 1</a> 中提到的关于 共享元素 transition 的知识点，然后说一说在 Android Lollipop 中是怎样使用它来构建合适的过渡动画。</p>
<p>##什么是 共享元素 Transition ?</p>
<p>共享元素 transition 决定了 共享元素 视图(也叫做主角视图)在<br>Activity/Fragment 场景过渡时的动画效果。共享元素 的动画<br>在被调用 Activity/Fragment  的 <strong>进入/返回</strong>  共享元素 transition<br><a id="1" href="#b1">(1)</a> 中执行，<br>可以通过下面的<a href="http://developer.android.com/reference/android/view/Window.html" target="_blank" rel="external">Window</a>/<a href="http://developer.android.com/reference/android/app/Fragment.html" target="_blank" rel="external">Fragment</a> 方法设置：</p>
<ul>
<li><strong>setSharedElementEnterTransition()</strong> -  <strong>B</strong> 的 <strong>进入</strong> 共享元素 transition ，执行将<br>共享元素视图 从 <strong>A</strong> 中的起始位置移动到它在 <strong>B</strong> 中的最终位置的动画。</li>
<li><strong>setSharedElementReturnTransition()</strong>  - <strong>B</strong> 的 <strong>返回</strong> 共享元素 transition ，执行将<br>共享元素视图 从 <strong>B</strong> 中起始位置移动到它在 <strong>A</strong> 中的最终位置的动画。</li>
</ul>
<p><a href="http://www.androiddesignpatterns.com/assets/videos/posts/2015/01/12/music-opt.mp4" target="_blank" rel="external"><strong>Video 3.1</strong></a> 展示了在 Google Play Music 中是怎样使用共享元素 transition<br>的。这个 transition 包含两个元素：一个 <strong>ImageView</strong>和它的父视图 <strong>CardView</strong>。<br>Transition 期间，<strong>CardView</strong> 会扩展到全屏或收缩回原状，<br><strong>ImageView</strong> 能在这两个 Activity 里无缝的衔接。</p>
<p>在 <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-transitions-in-android-lollipop-part1.html" target="_blank" rel="external">part1 </a> 里只是简单的介绍了下这个话题，这篇文章将会对 共享元素 transition<br>做更深度的分析。例如 共享元素 Transition 在底层是如何实现的？都有哪些类型的 Transition 对象可以使用? Transition 期间 共享元素视图 是在哪里怎样绘制的？接下来的几章里<br>我们会逐个解答这些问题。</p>
<p>##深入共享元素 Transitions 底层</p>
<p>之前的文章已经介绍过 Transition 的两个主要任务分别是获取目标视图的 开始&amp;结束 状态和创建这两个状态间视图的过渡动画(Animator)。共享元素 Transition 也一样：<br>在创建动画前需要捕获每一个<br>共享元素视图的起始和结束状态(就是共享元素在 <strong>调用/被调用</strong> Activity/Fragment<br>里的位置，大小和外观)。有了这些信息 共享元素 Transition 就可以确定每一个 共享元素<br>视图应该执行的动画。</p>
<p>和 <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-content-transitions-in-depth-part2.html" target="_blank" rel="external">Content Transitions 的底层</a>相似，框架通过在运行时明确的<br>更改每个 共享元素视图 的属性将这个状态信息提供给 共享元素 Transition 。<br>更准确地说 Activity <strong>A</strong> 启动 Activity <strong>B</strong> 时将会出现以下事件：<a id="2" href="#b2">(2)</a></p>
<hr>
<ol>
<li>Activity <strong>A</strong> 调用 <strong>startActivity()</strong> 构造，测量，布局了一个<br>最初背景色为透明的半透明窗口 Activity <strong>B</strong> 。</li>
<li>框架将 <strong>B</strong> 中每一个共享元素视图复位到对应的原来在 <strong>A</strong> 中时的位置，接着 <strong>B</strong> 的进入 transition 捕获 <strong>B</strong> 中所有共享元素视图的起始状态。</li>
<li>框架将 <strong>B</strong> 中每一个共享元素视图复位到对应的在 <strong>B</strong> 的最终位置，接着 <strong>B</strong> 的进入 transition 捕获 B 中所有共享元素视图的结束状态。</li>
<li><strong>B</strong> 的进入 transition 比较所有共享元素视图的起始和结束状态，根据它们的不同<br>创建一个 <strong>Animator</strong>。</li>
<li>框架命令 <strong>A</strong> 隐藏共享元素视图，并运行返回的 <strong>Animator</strong>。<strong>B</strong> 中的<br>共享元素视图到位之后，<strong>B</strong> 的窗口背景在 <strong>A </strong>上逐渐显示，直到 <strong>B</strong><br>完全的显示出来，transition 运行完毕。</li>
</ol>
<hr>
<p>Content transitions 是根据每个过渡视图的可见性变化来调节的，<strong>共享元素 transition<br>是根据每个共享元素视图的位置，大小和外观的变化来调节的</strong>。从 API 21 开始，框架提供了<br>几个自定义共享元素场景切换动画的 <strong>Transition</strong> 实现。</p>
<ul>
<li><a href="https://developer.android.com/reference/android/transition/ChangeBounds.html" target="_blank" rel="external">ChangeBounds</a> - 捕获共享元素布局边界根据不同构造动画。<br><strong>ChangeBounds</strong> 在共享元素 Transition 中经常使用，大多数共享元素在两个<br>Activity/Fragment 间会有大小 或/和 位置不同。 </li>
<li><a href="https://developer.android.com/reference/android/transition/ChangeTransform.html" target="_blank" rel="external">ChangeTransform</a>  - 捕获共享元素缩放和角度，<br>根据不同构建动画<a id="3" href="#b3">(3)</a>。</li>
<li><a href="https://developer.android.com/reference/android/transition/ChangeClipBounds.html" target="_blank" rel="external">ChangeClipBounds</a> - 捕获共享元素的 <a href="https://developer.android.com/reference/android/view/View.html#getClipBounds()" target="_blank" rel="external">clip bounds</a><br>(剪辑边界) ，根据不同构建动画。</li>
<li><a href="https://developer.android.com/reference/android/transition/ChangeImageTransform.html" target="_blank" rel="external">ChangeImageTransform</a> - 捕获共享元素 ImageView 的<br>变换矩阵( transform matrices) ，根据不同构建动画。结合 <strong>ChangeBounds</strong>，<br>可以让 ImageView<br> 无缝的改变大小，形状和 <a href="https://developer.android.com/reference/android/widget/ImageView.ScaleType.html" target="_blank" rel="external"> ImageView.ScaleType </a>。 </li>
<li><a href="https://github.com/android/platform_frameworks_base/blob/lollipop-release/core/res/res/transition/move.xml" target="_blank" rel="external">@android:transition/move</a> - 一个 <strong>TransitionSet</strong> ，同时执行上面四种<br>transition 。在 <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-transitions-in-android-lollipop-part1.html" target="_blank" rel="external">part 1</a> 里提到过，如果没有明确的声明 进入/返回 共享元素<br>transition ，框架会默认运行这个 transition。</li>
</ul>
<hr>
<p>在上面的例子中，我们还可以发现 <strong>共享元素视图实例并没有在 Activities/Fragments 间<br>“共享”</strong>。事实上，进入/返回 共享元素 transitions期间，用户看到的绝大多数东西都是在<br><strong>B</strong> 的 content view 中绘制的。框架并没有从 <strong>A</strong> 向 <strong>B</strong><br>传递 共享元素视图实例，<br>而是采用了不同的方法实现相同的视觉效果。当 <strong>A</strong> 启动 <strong>B</strong> ，框架收集 <strong>A</strong><br>中共享元素的所有相关信息，并传递给 <strong>B</strong>。接下来 <strong>B</strong> 使用这些信息初始化<br>共享元素视图的起始状态(它们在 <strong>A</strong> 中时对应的大小，位置和外观)。Transition<br>开始时，B 中除了共享元素视图外的所有东西都被初始化为对用户不可见。Tansition<br>的执行过程中，框架将 B 的 Activity 窗口逐渐显示，直到 B<br>中共享元素结束动画窗口变为不透明。</p>
<hr>
<p>##使用共享元素 Overlay <a id="4" href="#b4">(4)</a><br>最后，如果想要完全理解共享元素 transition 的运作，我们必须先说说共享元素 overlay。<br>可能不是很明显，<strong>共享元素默认是在整个窗口视图层的顶层  <a href="https://developer.android.com/reference/android/view/ViewOverlay.html" target="_blank" rel="external">ViewOverlay</a><br>上绘制</strong>。简单介绍下 ，<br><strong>ViewOverlay</strong> 这个类是在 API 18 中为了方便在视图层顶层<br>绘制引入的。添加到视图 <strong>ViewOverlay</strong> 之中的Drawable<br>和 view (甚至是一个 <strong>ViewGroup</strong> 的子类) ，<br>将会被绘制在视图的最上层。这就解释了框架为什么<br>默认选择在窗口视图层的  <strong>ViewOverlay</strong> 中绘制共享元素。<br>共享元素视图应该是贯穿整个 transition 的焦点；<br>如果 transitioning views 意外的绘制在共享元素之上就会<br>破坏这个效果<a id="5" href="#b5">(5)</a>。</p>
<hr>
<p>虽然共享元素默认绘制在共享元素的 ViewOverlay 之中，但是<br>框架也提供了关闭 overlay 的方法，只要调用<br><a href="https://developer.android.com/reference/android/view/Window.html#setSharedElementsUseOverlay(boolean)" target="_blank" rel="external">Window#setSharedElementsUseOverlay(false) </a><br>就可以了。如果你关闭了 overlay<br>，要留意这样做可能会引起的副作用。例如，<a href="http://www.androiddesignpatterns.com/assets/videos/posts/2015/01/12/overlay-opt.mp4" target="_blank" rel="external">Video 3.2</a><br> 执行了一个简单的共享元素 transition 两次，<br>一次开启和一次关闭 共享元素 overlay 。第一次达到了预期想要的结果，<br>第二次关闭 overlay 后运行的效果不理想。Transition view 从底部向上移入<br>调用 Activity 的 content view 时挡住了部分 共享元素 <strong>ImageView</strong> 。虽然<br>可以改变在 View 上绘制视图的顺序或者通过在共享元素 parent 里调用<br> <strong>setClipChildren(false)</strong> 这些旁门左道来修复问题，但是与可能带来的维护问题<br> 相比真是得不偿失。总之，除非你感觉必须要关掉共享元素 overlay 才能达到你想要的效果，<br> 其他情况尽量不要关闭它，这样会保持代码简洁，并且共享元素 transition 效果更引人注目。</p>
<p>##结语</p>
<p>综上所诉，这篇文章讲了三个重点:</p>
<ol>
<li>共享元素 transition 确定 共享元素视图(主角视图) 从一个 Activity/Fragment 移动到<br>另一个其间场景过渡的动画。</li>
<li>共享元素 transition 是根据每一个 共享元素视图 的位置，大小，和外观的变化调节的。</li>
<li>共享元素默认是绘制在窗口视图的顶层 <strong>ViewOverlay</strong> 上面的。</li>
</ol>
<p>希望这篇文章对你有所帮助 ～</p>
<hr>
<p>1 Note that the Activity Transition API gives you the ability to also specify exit and reenter shared element transitions using the setSharedElementExitTransition() and setSharedElementReenterTransition() methods, although doing so is usually not necessary. For an example illustrating one possible use case, check out this blog post. For an explanation why exit and reenter shared element transitions are not available for Fragment Transitions, see George Mount’s answer and comments in this StackOverflow post. ↩</p>
<p>2 A similar sequence of events occurs during the exit/return/reenter transitions for both Activities and Fragments. ↩</p>
<p>3 One other subtle feature of ChangeTransform is that it can detect and handle changes made to a shared element view’s parent during a transition. This comes in handy when, for example, the shared element’s parent has an opaque background and is by default selected to be a transitioning view during the scene change. In this case, the ChangeTransform will detect that the shared element’s ｀parent is being actively modified by the content transition, pull out the shared element from its parent, and animate the shared element separately. See George Mount’s StackOverflow answer for more information. ↩</p>
<p>4 Note that this section only pertains to Activity Transitions. Unlike Activity Transitions, shared elements are not drawn in a ViewOverlay by default during Fragment Transitions. That said, you can achieve a similar effect by applying a ChangeTransform transition, which will have the shared element drawn on top of the hierarchy in a ViewOverlay if it detects that its parent has changed. See this StackOverflow post for more information. ↩</p>
<p>5 Note that one negative side-effect of having shared elements drawn on top of the entire view hierarchy is that this means it will become possible for shared elements to draw on top of the System UI (such as the status bar, navigation bar, and action bar). For more information on how you can prevent this from happening, see this Google+ post. ↩</p>
<ol>
<li><p>Activity Transition API 也提供了<br><strong>setSharedElementExitTransition()</strong> 和 <strong>setSharedElementReenterTransition()</strong><br>这两个方法来设置 退出/重入 共享元素过渡，虽然通常来说是不必要的。<br><a href="https://halfthought.wordpress.com/2014/12/08/what-are-all-these-dang-transitions/" target="_blank" rel="external">这篇文章</a>介绍了一个可能会遇到的用例。在这个 <a href="http://stackoverflow.com/questions/27346020/understanding-exit-reenter-shared-element-transitions" target="_blank" rel="external">stackoverflow</a><br>提问中 George Mount 的回答解释了为什么 退出/重入 共享元素 transition 在<br>Fragment Transitions 中不可用。 <a id="b1" href="#1">↩</a></p>
</li>
<li><p>Activities 和 Fragments 的 退出/返回/重入 transition 过程中出现事件序列相似  <a id="b2" href="#2">↩</a></p>
</li>
<li><strong>ChangeTransform</strong> 还有一个超赞的特性，它可以检测并处理共享元素父视图过渡期间<br>   的改变。当共享元素父视图有一个不透明背景，在场景变换过程中默认被选为<br>   transitioning view 时，<strong>ChangeTransform</strong> 就有了用武之地。如果它检测出<br>   共享元素父视图已被 content transition 更改，就会将共享元素提取出来，单独执行<br>   共享元素的动画。<a href="http://stackoverflow.com/questions/26899779/enter-transition-on-a-fragment-with-a-shared-element-targets-the-shared-element" target="_blank" rel="external">StackOverflow answer</a> 这里有 George Mount<br>   的详细说明。<br>   <a id="b3" href="#3">↩</a></li>
<li>注意，这部分只与 Activity Transition 有关。和Activity Transition 不同，Fragment Transition<br>   期间共享元素默认不在 <strong>ViewOverlay</strong> 中绘制。尽管如此，你仍可以使用 ChangeTransform<br>   transition 来达到相似的效果，如果它检测到父视图改变了，就会把共享元素绘制在<br>   <strong>ViewOverlay</strong> 的顶层。<a href="http://stackoverflow.com/questions/27892033/is-there-a-setsharedelementsuseoverlay-method-for-fragment-transitions" target="_blank" rel="external">StackOverflow</a> 这里有更多信息。<pre><code>&lt;a id=&quot;b4&quot; href=&quot;#4&quot;&gt;↩&lt;/a&gt;
</code></pre></li>
<li>注意，将共享元素绘制在整个图层最顶层也有一些负面效果。有可能<br>   会将共享元素绘制在 System UI 之上(比如 status bar, navigation bar还有 action bar)。<br>   解决方法看这里 <a href="https://plus.google.com/+AlexLockwood/posts/RPtwZ5nNebb" target="_blank" rel="external">Google+ post</a>。<br>   <a id="b5" href="#5">↩</a></li>
</ol>
<hr>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/04/27/深入理解Shared-Element-Transition/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/04/27/深入理解Shared-Element-Transition/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/27/适用于Android的Flux架构/" title="适用于Android的Flux架构" itemprop="url">适用于Android的Flux架构</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kevin" target="_blank" itemprop="author">Kevin</a>
		
  <p class="article-time">
    <time datetime="2017-04-27T10:28:07.000Z" itemprop="datePublished"> 发表于 2017-04-27</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Flux Architecture on Android</p>
<p>适用于Android的Flux架构</p>
<p>Finding a good architecture for Android applications is not easy. Google<br>seems to not care much about it, so there is no official recommendation<br>on patterns beyond Activities lifecycle management.</p>
<p>找到一个好的应用架构对于Android来说并非易事，Goodle似乎并不那么关心这方面，因为他们并没有推荐一个合适的应用架构。</p>
<p>But defining an architecture for your application is important. Like it<br>or not, <strong>every application is going to have an architecture</strong>. So you’d<br>better be the one defining it than let it just emerge.</p>
<p>但是对于应用来说一个良好的架构是非常重要的。不管你是否同意，每个应用都应该有一个架构。因此，你最好为你的应用设计一个架构，而不是任由它发展。</p>
<h2 id="Today-Clean-Architecture"><a href="#Today-Clean-Architecture" class="headerlink" title="Today: Clean Architecture"></a>Today: Clean Architecture</h2><h2 id="清晰的软件架构"><a href="#清晰的软件架构" class="headerlink" title="清晰的软件架构"></a>清晰的软件架构</h2><p>Current trend is to adapt <a href="https://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="external">Clean<br>Architecture</a>,<br>a 2012 Uncle Bob proposal for web applications.</p>
<p>现在比较流行的架构是Bob大叔在2012年发表的、针对于Web应用的<a href="https://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="external">清晰的软件架构</a>。</p>
<p>I find Clean Architecture a little bit <strong>over-engineered</strong> for most of<br>the Android apps out there.</p>
<p>但是我发现这个清晰的软件架构对于Android应用来说太过重量级了。</p>
<p>Typically <strong>mobile apps live shorter than web apps</strong>. Mobile technology<br>is evolving so fast that any app released today is going to be<br>completely deprecated in twelve months.</p>
<p>通常来说，移动应用都比web应用要简单。移动技术变化得很快，以至于今天发布的应用可能在一年之后就过时了。</p>
<p>Mobile apps usually <strong>do very little</strong>. A very high percent of use cases<br>are just for data consuming. Get data from API, show data to user. Lot<br>of reads, very little writes.</p>
<p>移动应用通常比较简单，比较多的使用场景只是对数据的处理。从API获取数据、向用户展示数据。更多的是阅读，很少有写内容的需求。</p>
<p>As a result its <strong>business logic is not complex</strong>. At least not as<br>complex as backend apps. Well you have to deal with platform issues:<br>memory, storage, pause, resume, network, location, etc. But that is not<br>your app business logic. You have all of that in every app.</p>
<p>这也使得移动应用的<code>业务逻辑不会太过于复杂</code>，至少不会比后端的应用复杂。当然，你也需要处理一些移动平台的问题:内存，存储，暂停，重新运行，网络，地理位置等等。但是这些并不是你的业务逻辑。 </p>
<p>So it seems that most of the apps out there will not benefit from things<br>like complex layer divisions or job priority execution queues.</p>
<p>因此，对于大多数应用来说并不会从复杂的分层架构或者具有优先级的任务队列中获得太多益处。</p>
<p>They may just need a <strong>simple way to organise code, work together<br>efficiently and find bugs easily</strong>.</p>
<p>它们可能只是需要简单的方式来组织代码，使得各部分组件之间高效的一起工作，并且容易查找bug。</p>
<h2 id="Introducing-Flux-Architecture"><a href="#Introducing-Flux-Architecture" class="headerlink" title="Introducing Flux Architecture"></a>Introducing Flux Architecture</h2><h2 id="Flux-应用架构简介"><a href="#Flux-应用架构简介" class="headerlink" title="Flux 应用架构简介"></a>Flux 应用架构简介</h2><p><a href="https://facebook.github.io/flux/docs/overview.html" target="_blank" rel="external">Flux Architecture</a> is used by Facebook to build their client- side web applications. Like<br><em>Clean Architecture</em> it is not intended for mobile apps, but its<br>features and simplicity will allow us to adapt it very well to Android<br>projects.</p>
<p><strong><a href="https://facebook.github.io/flux/docs/overview.html" target="_blank" rel="external">Flux应用架构</a></strong>被facebook用于架构客户端Web应用，与<em>Clean Architecture</em>类似它也不是针对于移动应用的，它更简洁性能够让我们很方面的适用于Android应用。</p>
<p><img src="http://img.blog.csdn.net/20150810172158465" alt="flux-graph-simple"></p>
<p>There are two <strong>key features</strong> to understand Flux:</p>
<p>有两个关键特性能够帮助我们理解Flux : </p>
<ul>
<li><p>The data flow is always <strong>unidirectional</strong>.</p>
<p>An <a href="https://www.youtube.com/watch?v=i__969noyAM" target="_blank" rel="external">unidirectional data<br>flow</a> is the <strong>core</strong><br>of the Flux architecture and is what makes it so easy to learn. It<br>also provides great advantages when testing the application as<br>discussed below.</p>
</li>
<li><p>数据流总是单向的</p>
<pre><code>一个 [单向数据流](https://www.youtube.com/watch?v=i__969noyAM)是Flux 应用架构的核心，这也使得它很容易学习。当你需要测试应用时它也提供了很便利的条件。
</code></pre></li>
<li><p>The application is divided into <strong>three main parts</strong>:</p>
<ul>
<li><strong>View</strong>: Application interface. It create actions in response<br>to user interactions.</li>
<li><strong>Dispatcher</strong>: Central hub through which pass all actions and<pre><code>whose responsibility is to make them arrive to every Store.
</code></pre></li>
<li><strong>Store</strong>: Maintain the state for a particular application<pre><code>domain. They respond to actions according to current state,
execute business logic and emit a *change* event when they are
done. This event is used by the view to update its interface.
</code></pre></li>
</ul>
</li>
<li>应用分为三部分 : <ul>
<li><strong>View</strong> : 应用接口,它用于将用户的交互转换为Action。</li>
<li><strong>Dispatcher</strong> : 中央分发器,将所有action分发到处理它们每个Store;</li>
<li><strong>Store</strong> : 维护特定应用领域的状态。它们根据当前的状态对action做出处理,执行业务逻辑,并且在处理完成时发出<em>change</em>事件。这个事件用于通知View更新UI。</li>
</ul>
</li>
</ul>
<p>This three parts communicate through <strong>Actions</strong>: Simple plain objects,<br>identified by a type, containing the data related to that action.</p>
<p>这三部分通过<strong>Action</strong>交互,Action是通过type标识的简单对象,它包含了一些与action相关的数据。</p>
<h2 id="Flux-Android-Architecture"><a href="#Flux-Android-Architecture" class="headerlink" title="Flux Android Architecture"></a>Flux Android Architecture</h2><h2 id="适用于Android的Flux架构"><a href="#适用于Android的Flux架构" class="headerlink" title="适用于Android的Flux架构"></a>适用于Android的Flux架构</h2><p>The main target of using Flux principles on Android development is to<br>build an architecture with a good balance between simplicity and ease of<br>scale and test.<br>在Android开发中使用Flux原则的主要目标就是创建一个简单、可伸缩、易于测试的应用架构。</p>
<p>First step is to <strong>map Flux elements with Android app components</strong>.</p>
<p>第一步需要做的就是<strong>在Android组件之间建立Flux元素的关系映射</strong>。</p>
<p>Two of this elements are very easy to figure out and implement.</p>
<p>这两类元素非常容易实现 : </p>
<ul>
<li><strong>View</strong>: Activity or Fragment</li>
<li><p><strong>Dispatcher</strong>: An event bus. I will use Otto in my examples but any</p>
<pre><code>other implementation should be fine.
</code></pre></li>
<li><p><strong>View</strong>: Activity 或 Fragment;</p>
</li>
<li><strong>Dispatcher</strong>: 一个事件总线,我在示例中使用了Otto，但是其他实现也是可以考虑的，例如<a href="https://github.com/bboyfeiyu/AndroidEventBus" target="_blank" rel="external">AndroidEventBus</a>。</li>
</ul>
<h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p>Actions are not complex either. They will be implemented as simple POJOs<br>with two main attributes:</p>
<p>Action也不复杂,它们通常是一些含有如下两个主要属性的简单的对象: </p>
<ul>
<li>Type: a <code>String</code> identifying the type of event.</li>
<li><p>Data: a <code>Map</code> with the payload for this action.</p>
</li>
<li><p>Type : 标识事件类型的一个String字段;</p>
</li>
<li>Data : 一个含有该Action信息的map字段。</li>
</ul>
<p>For example, a typical action to show some User details will look like<br>this:</p>
<p>例如,一个显示一些用户详细的action大致如下所示 : </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Bundle data = <span class="keyword">new</span> Bundle();</div><div class="line">data.put(<span class="string">"USER_ID"</span>, id);</div><div class="line">Action action = <span class="keyword">new</span> ViewAction(<span class="string">"SHOW_USER"</span>, data);</div></pre></td></tr></table></figure>
<h3 id="Stores"><a href="#Stores" class="headerlink" title="Stores"></a>Stores</h3><p>This is perhaps the <strong>most difficult</strong> to get Flux concept.</p>
<p>Stores应该是Flux概念里最难理解的了。</p>
<p>Also if you have worked with Clean Architecture before it also will be<br>uncomfortable to accept, because Stores will assume responsibilities<br>that were previously separated into different layers.</p>
<p>如果你以前使用过Clean Architecture,你会感觉它也不是那么容易理解，因为Stores会假设职责已经被分割到不同的层。</p>
<p>Stores contain the <strong>status of the application and its business logic</strong>.<br>They are similar to <em>rich data models</em> but they can manage the status of<br><strong>various objects</strong>, not just one.</p>
<p>Stores包含了<strong>应用的状态以及业务逻辑</strong>，它们很像<strong>功能完备的数据模型</strong>,但它们能够管理各种对象的状态,而不仅仅是其中一个。</p>
<p>Stores <strong>react to Actions emitted by the Dispatcher</strong>, execute business<br>logic and emit a change event as result.</p>
<p>Stores对Dispatcher发出的Action做出响应,执行业务逻辑,处理完成之后发出一个change事件。</p>
<p>Stores only output is this single event: <em>change</em>. Any other component<br>interested in a Store internal status must listen to this event and use<br>it to get the data it needs.</p>
<p>Stores只会输出一个<strong>change</strong>事件,任何对一个Store的内部状态感兴趣的组件都需要监听该事件,并且使用它来获取数据。</p>
<p>No other component of the system should need to know anything about the<br>status of the application.</p>
<p>系统中的其他部分并不需要了解应用的状态。</p>
<p>Finally, stores must <strong>expose an interface</strong> to obtain application<br>Status. This way, view elements can query the Stores and update<br>application UI in response.</p>
<p>最终,Store必须暴露一个接口来获取应用状态.这样一来，View元素就能够查询Store的状态以及更新UI。</p>
<p><img src="http://img.blog.csdn.net/20150810172207045" alt="flux-graph-store"></p>
<p>For example, in a Pub Discovery App a SearchStore will be used to keep<br>track of searched item, search results and the history of past searches.<br>In the same application a ReviewedStore will contain a list of reviewed<br>pubs and the necessary logic to, for example, sort by review.</p>
<p>例如，在一个酒吧查找App中，SearchStore被用于追踪搜索到的酒吧、搜索结果和经过的酒吧历史数据。另一个ReviewedStore包含查看过的酒吧列表以及必须的逻辑，例如排序。</p>
<p>However there is one important concept to keep in mind: <strong>Stores are not<br>Repositories</strong>. Their responsibility is <em>not</em> to get data from an<br>external source (API or DB) but only keep track of data provided by<br>actions.</p>
<p>然后，有有一个重要的概念你必须要记住 : <strong>Store不是Repositories</strong>。它们的职责不是从外部资源（API或者数据库）中获取数据，只是追中action提供的数据。</p>
<p>So how Flux application obtain data?</p>
<p>那么Flux如何获取数据呢 ？</p>
<h2 id="Network-requests-and-asynchronous-calls"><a href="#Network-requests-and-asynchronous-calls" class="headerlink" title="Network requests and asynchronous calls"></a>Network requests and asynchronous calls</h2><h2 id="网络请求与异步调用"><a href="#网络请求与异步调用" class="headerlink" title="网络请求与异步调用"></a>网络请求与异步调用</h2><p>In the initial Flux graph I intentionally skipped one part: <strong>network<br>calls</strong>. Next graph completes first one adding more details:</p>
<p>在前面的Flux图表中我特意省略了一部分: <strong>网络调用</strong>。下一个图表将会完善这部分细节。</p>
<p><img src="http://img.blog.csdn.net/20150810172211077" alt="flux-graph-complete"></p>
<p>Asynchronous network calls are triggered from an <strong>Actions Creator</strong>. A<br>Network Adapter makes the asynchronous call to the corresponding API and<br>returns the result to the Actions Creator.</p>
<p>异步网络调用会从<strong>Actions Creator</strong>触发，一个网络适配器会触发一个异步的网络调用并且将结果返回到<strong>Actions Creator</strong>中。</p>
<p>Finally the Actions Creator dispatch the corresponding typed Action with<br>returned data.</p>
<p>最终<strong>Actions Creator</strong>将含有相应type与数据的Action分发出去。</p>
<p>Having all the network and asynchronous work out of the Stores has has<br><strong>two main advantages</strong>:</p>
<p>所有的网络请求和异步操作从Store中隔离出来有两个优点 : </p>
<ul>
<li><p><strong>Your Stores are completely synchronous</strong>: This makes the logic<br>inside a Store very easy to follow. Bugs will be much easier to<br>trace. And since <strong>all state changes will be synchronous</strong> testing a<br>Store becomes an easy job: launch actions and assert expected final<br>state.</p>
</li>
<li><p><strong>Store中的操作都是是完全同步的</strong> : 这使得Store中的业务逻辑非常简单，bug也易于发现。并且，自从”所有的状态变化都必须是同步的”的运用到实际中，测试Store变得非常容易，只需要加载action，然后对最终的状态做一个断言判断;</p>
</li>
<li><p><strong>All actions are triggered from an Action Creator</strong>: Having a</p>
<pre><code>single point at which you create and launch all user actions greatly
simplifies finding errors. Forget about digging into classes to find
out where an action is originated. **Everything starts here**. And
because asynchronous calls occur *before*, everything that comes out
of ActionCreator is synchronous. This is a huge win that
significantly improves traceability and testability of the code.
</code></pre></li>
<li><p><strong>所有Action都是从Action Creator被触发</strong> : 从一个统一的点创建和启动所有用户的action使得查找错误变得很简单。省去了在各种Class之间查找该action的发出点,<strong>所有的action都出自Action Creator</strong>。因为异步调用在action发出之前已经调用，因此其他ActionCreator的函数都是同步的，这很大程度上提升了代码的可追踪性和可测试性。</p>
</li>
</ul>
<h2 id="Show-me-the-code-To-Do-App"><a href="#Show-me-the-code-To-Do-App" class="headerlink" title="Show me the code: To-Do App"></a>Show me the code: To-Do App</h2><p><a href="https://github.com/lgvalle/android-flux-todo-app" target="_blank" rel="external">In this example</a> you<br>will find a classical <strong>To-Do App</strong> implemented on Android using a Flux<br>Architecture.</p>
<p><a href="https://github.com/lgvalle/android-flux-todo-app" target="_blank" rel="external">这个例子</a>是按照Flux架构实现的To-Do Android应用。</p>
<p>I tried to keep the project as simple as possible just to show how this<br>architecture can produce <strong>very well organised apps</strong>.</p>
<p>我尝试着尽量简单的演示如何使用Flux架构来构建一个组织良好的应用。</p>
<p>Some comments about implementation:</p>
<p>关于这个实现的一些解释 : </p>
<ul>
<li><p>The <code>Dispatcher</code> is implemented using Otto Bus. Any bus<br>implementation will mostly work. There is a <strong>Flux restriction</strong> on<br>events I’m not applying here. On original Flux definition<br>dispatching an event before previous one has finish is forbidden and<br>will throw an exception. To keep the project simple I’m not<br>implementing that here.</p>
</li>
<li><p>Dispatcher是使用了Otto事件总线实现。任何的事件总线也都可以的啦。在原来的Flux定义中,在上一个事件结束前就分发一个新的事件是不允许的,此时会抛出异常。为了代码比较简单，我在这个项目中并没有实现这个功能;</p>
</li>
<li><p>There is an <code>ActionsCreator</code> class to help creating <code>Actions</code> and</p>
<pre><code>posting them into the `Dispatcher`. It is a pretty common pattern in
Flux which keeps things organised.
</code></pre></li>
<li><p>ActionsCreator类用于创建Action和将它们投递到<code>Dispatcher</code>。在Flux中这是一种比较常见的模式。</p>
</li>
<li><p><code>Actions</code> types are just <code>String</code> constants. It is probably not the</p>
<pre><code>best implementation but is quick and helps keeping things simple.
</code></pre></li>
<li>Action类型只有字符串常量。这也许不是最好的实现,但是是最快、最能保持简洁性的。</li>
</ul>
<p>Same thing with <code>Actions</code> data: they are just a <code>HashMap</code> with a<br><code>String</code> key and <code>Object</code> as a value. This forces ugly castings on<br>Stores to extract actual data. Of course, this is not type safe but<br>again, keeps the example easy to understand.</p>
<p>Action中的数据也只是使用key为String、value为Object类型的<code>HashMap</code>来存储。因此这需要你在Store中进行强制类型转换，一般得到具体的Action数据。当然，这并不是类型安全的,还是那句话 : 为了保持简单性。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>There is <strong>no such thing as the Best Architecture for an Android app</strong>.<br>There <em>is</em> the Best Architecture for your current app. And it is the one<br>that let you collaborate with your teammates easily, finish the project<br>on time, with quality and as less bugs as possible.</p>
<p>没有什么最好的Android应用架构，只有最适合你应用的架构。这个架构能够使你你和你的队友很方便地一起协作,在规定的时间内高质量的完成你的应用。</p>
<p>I believe Flux is very good for all of that.</p>
<p>我相信Flux架构在这些方面还是比较靠谱的，不信就自己动手试试吧！</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p><a href="https://github.com/lgvalle/android-flux-todo-app" target="_blank" rel="external">代码在这里</a></p>
<h2 id="深度阅读"><a href="#深度阅读" class="headerlink" title="深度阅读"></a>深度阅读</h2><ul>
<li><a href="https://facebook.github.io/flux/docs/overview.html" target="_blank" rel="external">Facebook Flux<br>Overview</a></li>
<li>[Testing Flux<pre><code>Applications](https://facebook.github.io/flux/docs/testing-flux-applications.html#content)
</code></pre></li>
<li>[Flux architecture Step by<pre><code>Step](http://blogs.atlassian.com/2014/08/flux-architecture-step-by-step/)
</code></pre></li>
<li>[Async Requests and<pre><code>Flux](http://www.code-experience.com/async-requests-with-react-js-and-flux-revisited/)
</code></pre></li>
<li>[Flux and<pre><code>Android](http://armueller.github.io/android/2015/03/29/flux-and-android.html)
</code></pre></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/04/27/适用于Android的Flux架构/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/04/27/适用于Android的Flux架构/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/27/延迟共享元素的过渡动画/" title="延迟共享元素的过渡动画 (part 3b)" itemprop="url">延迟共享元素的过渡动画 (part 3b)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kevin" target="_blank" itemprop="author">Kevin</a>
		
  <p class="article-time">
    <time datetime="2017-04-27T10:28:07.000Z" itemprop="datePublished"> 发表于 2017-04-27</time>
    
  </p>
</header>
    <div class="article-content">
        
        <ul>
<li>原文链接 : <a href="http://www.androiddesignpatterns.com/2015/03/activity-postponed-shared-element-transitions-part3b.html" target="_blank" rel="external">Postponed Shared Element Transitions (part 3b)</a></li>
</ul>
<p>通过讨论 Lollipop Transition API 的一个重要的特性：延迟共享元素的过渡动画，这篇博文将继续我们关于共享元素 Transition 的深度解析。这也是我关于 Transition 这个专栏的第四篇文章。</p>
<ul>
<li>Part 1: <a href="https://github.com/bboyfeiyu/android-tech-frontier/tree/master/others/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAAndroid%20%E6%96%B0%E7%89%B9%E6%80%A7-Transition-Part-1" target="_blank" rel="external">在 Activity 和 Fragment 中使用 Transition </a></li>
<li>Part 2: <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-content-transitions-in-depth-part2.html" target="_blank" rel="external">深入理解 Transition</a></li>
<li>Part 3a: <a href="http://www.androiddesignpatterns.com/2015/01/activity-fragment-shared-element-transitions-in-depth-part3a.html" target="_blank" rel="external">深入理解共享元素的 Transition</a></li>
<li>Part 3b:  <a href="http://www.androiddesignpatterns.com/2015/03/activity-postponed-shared-element-transitions-part3b.html" target="_blank" rel="external">延迟共享元素的 Transition</a></li>
<li>Part 3c: 共享元素回调实践 (coming soon!)</li>
<li>Part 4:  Activity &amp; Fragment 过渡动画示例(coming soon!)</li>
</ul>
<p>我们通过一个常见的问题来解释为什么需要推迟某些共享元素的过渡动画。</p>
<p>##理解问题</p>
<p>通常问题的根源是框架在 Activity 生命周期非常早的时候启动共享元素 Transition 。回想我们的第一篇文章，Transitions 必须捕获目标 View 的起始和结束状态来构建合适的动画。因此，如果框架在共享元素获得它在调用它的 Activity 中所给定的大小和位置前启动共享元素的过渡动画，这个 Transition 将不能正确捕获到共享元素的结束状态值,生成动画也会失败(一个过渡失败的例子<a href="http://www.androiddesignpatterns.com/assets/videos/posts/2015/03/09/postpone-bug-opt.mp4" target="_blank" rel="external">Video 3.3</a>).</p>
<p>Transition 开始前，能否计算出正确的共享元素的结束值主要依靠两个因素:</p>
<p>(1) 调用共享元素的 Activity 的布局复杂度以及布局层次结构的深度<br>(2)调用共享元素Activity载入数据消耗的时间</p>
<p>布局越复杂，在屏幕上确定共享元素的大小位置耗时越长。同样，如果调用共享元素的 Activity 依赖一个异步的数据载入，框架仍有可能会在数据载入完成前自动开始共享元素 Transition。下面列出的是你可能遇到的常见问题:</p>
<ul>
<li><p><strong>存在于 Activity 托管的 Fragment 中的共享元素</strong>。<a href="https://developer.android.com/reference/android/app/FragmentTransaction.html#commit()" target="_blank" rel="external">FragmentTransactions 在 commit 后并不会被立即执行</a>，它们会被安排到主线程中等待执行。因此，如果共享元素存在的 Fragment 的视图层和FragmentTransaction没有被及时执行，框架有可能在共享元素被正确测量大小和布局到屏幕前启动共享元素 Transition。<a id="b1" href="#1">(1)</a></p>
</li>
<li><p><strong>共享元素是一个高分辨率的图片</strong>。给 <strong>ImageView</strong> 设置一个超过其初始化边界的高分辨率图片，最终可能会导致在这个视图层里出现<a href="https://github.com/android/platform_frameworks_base/blob/lollipop-release/core/java/android/widget/ImageView.java#L453-L455" target="_blank" rel="external">额外的布局传递</a>，由此增加在共享元素准备好前就启动 Transition 的几率。流行的异步图片处理库比如 <a href="https://android.googlesource.com/platform/frameworks/volley" target="_blank" rel="external"><code>Volley</code></a> 和 <a href="http://square.github.io/picasso/" target="_blank" rel="external"><code>Picasso</code></a> ，也不能可靠的解决这个问题：框架不能预先了解图片是要被下载，缩放还是在后台线程中从磁盘读取，也不管图片是否处理完毕就启动共享元素 Transition。</p>
</li>
<li><p><strong>共享元素依赖于异步的数据加载</strong>如果共享元素所需的数据是通过<strong>AsyncTask</strong>，<strong>AsyncQueryHandler</strong>,<strong>Loader</strong>或者其他类似的东西加载，在它们获得在调用它们的 Activity 的最终数据（大小、位置）前，框架就有可能在主线程中启动 Transition。</p>
</li>
</ul>
<p>现在你可能会想：如果有办法能让暂时延迟 Transition 的使用，直到我们确定了共享元素的确切大小和位置才使用它就好了。幸好 Activity Transitions API<a id="b2" href="#2">(2)</a> 为我们提供了解决方案。</p>
<p>在 Activity 的<code>onCreate()</code>中调用<a href="https://developer.android.com/reference/android/app/Activity.html#postponeEnterTransition()" target="_blank" rel="external"><code>postponeEnterTransition()</code></a> 方法来暂时阻止启动共享元素 Transition。之后，你需要在共享元素准备好后调用 <a href="https://developer.android.com/reference/android/app/Activity.html#startPostponedEnterTransition()" target="_blank" rel="external"><code>startPostponedEnterTransition</code></a> 来恢复过渡效果。常见的模式是在一个<a href="http://developer.android.com/reference/android/view/ViewTreeObserver.OnPreDrawListener.html" target="_blank" rel="external"><code>OnPreDrawListener</code></a>中启动延时 Transition，它会在共享元素测量和布局完毕后被调用<a id="b3" href="#3">(3)</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">    <span class="comment">// Postpone the shared element enter transition.</span></div><div class="line">    postponeEnterTransition();</div><div class="line"></div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> Call the "scheduleStartPostponedTransition()" method</span></div><div class="line">    <span class="comment">// below when you know for certain that the shared element is</span></div><div class="line">    <span class="comment">// ready for the transition to begin.</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Schedules the shared element transition to be started immediately</div><div class="line"> * after the shared element has been measured and laid out within the</div><div class="line"> * activity's view hierarchy. Some common places where it might make</div><div class="line"> * sense to call this method are:</div><div class="line"> *</div><div class="line"> * (1) Inside a Fragment's onCreateView() method (if the shared element</div><div class="line"> *     lives inside a Fragment hosted by the called Activity).</div><div class="line"> *</div><div class="line"> * (2) Inside a Picasso Callback object (if you need to wait for Picasso to</div><div class="line"> *     asynchronously load/scale a bitmap before the transition can begin).</div><div class="line"> *</div><div class="line"> * (3) Inside a LoaderCallback's onLoadFinished() method (if the shared</div><div class="line"> *     element depends on data queried by a Loader).</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleStartPostponedTransition</span><span class="params">(<span class="keyword">final</span> View sharedElement)</span> </span>&#123;</div><div class="line">    sharedElement.getViewTreeObserver().addOnPreDrawListener(</div><div class="line">        <span class="keyword">new</span> ViewTreeObserver.OnPreDrawListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreDraw</span><span class="params">()</span> </span>&#123;</div><div class="line">                sharedElement.getViewTreeObserver().removeOnPreDrawListener(<span class="keyword">this</span>);</div><div class="line">                startPostponedEnterTransition();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>忽略方法名，这里还有第二种方法可以延迟共享元素的返回 Transition，在调用Activity的<a href="https://developer.android.com/reference/android/app/Activity.html#onActivityReenter(int,%20android.content.Intent)" target="_blank" rel="external"><code>onActivityReenter()</code></a> 方法中延缓返回 Transition<a id="b4" href="#4">(4)</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Don't forget to call setResult(Activity.RESULT_OK) in the returning</div><div class="line"> * activity or else this method won't be called!</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityReenter</span><span class="params">(<span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onActivityReenter(resultCode, data);</div><div class="line"></div><div class="line">    <span class="comment">// Postpone the shared element return transition.</span></div><div class="line">    postponeEnterTransition();</div><div class="line"></div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> Call the "scheduleStartPostponedTransition()" method</span></div><div class="line">    <span class="comment">// above when you know for certain that the shared element is</span></div><div class="line">    <span class="comment">// ready for the transition to begin.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>尽管添加延时可以让共享元素 Transition 更加流畅准确，但是你也要知道在应用中引入共享元素 Transition 的延迟可能会产生一些负面影响：</p>
<ul>
<li><strong>调用<code>postponeEnterTransition</code>后不要忘记调用<code>startPostponedEnterTransition</code></strong>。<br>忘记调用<code>startPostponedEnterTransition</code>会让你的应用处于死锁状态，用户无法进入下个Activity。</li>
</ul>
<ul>
<li><strong>不要将共享元素 Transition 延迟设置到1s以上</strong>。延迟时间过长会在应用中产生不必要的卡顿，影响用户体验。</li>
</ul>
<p>感谢阅读！希望这篇文章对你有所帮助。</p>
<p><a id="1" href="#b1"><strong>1</strong></a>: 当然，许多应用通过调用 <a href="https://developer.android.com/reference/android/app/FragmentManager.html#executePendingTransactions(" target="_blank" rel="external"><code>FragmentManager#executePendingTransactions()</code></a>) 来避开这个问题，这样会强制立即执行FragmentTransactions而不是异步。</p>
<p><a id="2" href="#b2"><strong>2</strong></a>: 注意!<code>postponeEnterTransition()</code>和<code>startPostponedEnterTransition()</code>只对 Activity Transition起作用，对Fragment无效。详细信息可以在这里找到 <a href="http://stackoverflow.com/questions/26977303/how-to-postpone-a-fragments-enter-transition-in-android-lollipop" target="_blank" rel="external">StackOverflow</a> &amp; <a href="https://plus.google.com/+AlexLockwood/posts/3DxHT42rmmY" target="_blank" rel="external">Google+</a></p>
<p><a id="3" href="#b3"><strong>3</strong></a>: 小贴士:你可以先调用 <a href="http://developer.android.com/reference/android/view/View.html#isLayoutRequested(" target="_blank" rel="external"><code>View#isLayoutRequested()</code></a>) 来确认是否需要调用 <a href="http://developer.android.com/reference/android/view/ViewTreeObserver.OnPreDrawListener.html" target="_blank" rel="external"><code>OnPreDrawListener</code></a>，有必要的话 <a href="http://developer.android.com/reference/android/view/View.html#isLaidOut(" target="_blank" rel="external"><code>View#isLaidOut()</code></a>) 在一些情况下也能派上用场</p>
<p><a id="4" href="#b4"><strong>4</strong></a>: 在开发者选项中启用不保留 Activity 选项可以方便调试共享元素返回/重新进入时对应过渡动画的行为，这也可以帮助测试在返回的过渡效果开始之前可能发生最糟糕的情况( Activity 需要重新构造布局加载数据…)</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/04/27/延迟共享元素的过渡动画/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/04/27/延迟共享元素的过渡动画/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/02/16/理解Java中的ThreadLocal/" title="理解Java中的ThreadLocal" itemprop="url">理解Java中的ThreadLocal</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kevin" target="_blank" itemprop="author">Kevin</a>
		
  <p class="article-time">
    <time datetime="2017-02-16T05:55:28.000Z" itemprop="datePublished"> 发表于 2017-02-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="理解Java中的ThreadLocal"><a href="#理解Java中的ThreadLocal" class="headerlink" title="理解Java中的ThreadLocal"></a>理解Java中的ThreadLocal</h1><p>之前面试的时候，面试官问题threadlocal怎么用？当时就懵逼了，只是见过，却不知道如何使用。</p>
<p>提到ThreadLocal，有些Android或者Java程序员可能有所陌生，可能会提出种种问题，它是做什么的，是不是和线程有关，怎么使用呢？等等问题，本文将总结一下我对ThreadLocal的理解和认识，希望让大家理解ThreadLocal更加透彻一些。</p>
<h4 id="ThreadLocal是什么？"><a href="#ThreadLocal是什么？" class="headerlink" title="ThreadLocal是什么？"></a>ThreadLocal是什么？</h4><p>ThreadLocal是一个关于创建线程局部变量的类。</p>
<p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。</p>
<h3 id="用法简介"><a href="#用法简介" class="headerlink" title="用法简介"></a>用法简介</h3><ul>
<li><p>创建，支持泛型</p>
<p><code>ThreadLocal&lt;String&gt; mStringThreadLocal = new ThreadLocal&lt;&gt;();</code></p>
</li>
<li><p>set方法</p>
<p><code>mStringThreadLocal.set(&quot;droidyue.com&quot;);</code></p>
</li>
<li><p>get方法</p>
<p><code>mStringThreadLocal.get();</code></p>
</li>
</ul>
<h3 id="完整的使用示例"><a href="#完整的使用示例" class="headerlink" title="完整的使用示例"></a>完整的使用示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private void testThreadLocal() &#123;</div><div class="line">    Thread t = new Thread() &#123;</div><div class="line">        ThreadLocal&lt;String&gt; mStringThreadLocal = new ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            super.run();</div><div class="line">            mStringThreadLocal.set(&quot;droidyue.com&quot;);</div><div class="line">            mStringThreadLocal.get();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    t.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>实现单个线程单例以及单个线程上下文信息存储，比如交易id等</li>
<li>实现线程安全，非线程安全的对象使用ThreadLocal之后就会变得线程安全，因为每个线程都会有一个对应的实例</li>
<li>承载一些线程相关的数据，避免在方法中来回传递参数</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/02/16/理解Java中的ThreadLocal/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/02/16/理解Java中的ThreadLocal/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/02/15/Java之数组array和集合list、set、map/" title="数组与集合" itemprop="url">数组与集合</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kevin" target="_blank" itemprop="author">Kevin</a>
		
  <p class="article-time">
    <time datetime="2017-02-15T09:16:28.000Z" itemprop="datePublished"> 发表于 2017-02-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="Java之数组array和集合list、set、map"><a href="#Java之数组array和集合list、set、map" class="headerlink" title="Java之数组array和集合list、set、map"></a>Java之数组array和集合list、set、map</h1><p>最基础的是array,所有的集合都是通过array实现的。</p>
<p>在代码中进行随机访问和存储，array的效率是最高的，但是array是固定的，不能动态改变，且一个array只能存放同一种数据类型。针对以上缺点，就出现了集合就是list,set,map。</p>
<p>java集合可以存储和操作不固定的一组数据，但是只能存放引用类型的数据，不能放基本数据类型。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/02/15/Java之数组array和集合list、set、map/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/02/15/Java之数组array和集合list、set、map/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/08/git命令使用大全/" title="Git命令使用大全" itemprop="url">Git命令使用大全</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kevin" target="_blank" itemprop="author">Kevin</a>
		
  <p class="article-time">
    <time datetime="2016-12-08T04:10:15.000Z" itemprop="datePublished"> 发表于 2016-12-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="1-新建代码库"><a href="#1-新建代码库" class="headerlink" title="1.新建代码库"></a>1.新建代码库</h4><ul>
<li><p>在当前目录新建一个Git代码库</p>
<p><code>$ git init</code></p>
</li>
<li><p>新建一个目录，将其初始化为Git代码库</p>
<p><code>$ git init [project-name]</code></p>
</li>
<li><p>下载一个项目和它的整个代码历史</p>
<p><code>$ git clone [url]</code></p>
</li>
</ul>
<h4 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h4><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<ul>
<li><p>显示当前的Git配置</p>
<p><code>$ git config —list</code></p>
</li>
<li><p>编辑Git配置文件</p>
<p><code>$ git config -e [—global]</code></p>
</li>
<li><p>设置提交代码时的用户信息</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config [--global] user.name &quot;[name]&quot;</div><div class="line">$ git config [--global] user.email &quot;[email address]&quot;</div></pre></td></tr></table></figure>
<h4 id="3-增加-删除文件"><a href="#3-增加-删除文件" class="headerlink" title="3.增加/删除文件"></a>3.增加/删除文件</h4><ul>
<li><p>添加指定文件到暂存区</p>
<p><code>$ git add [file1][file2] …</code></p>
</li>
<li><p>添加指定目录到暂存区，包括子目录</p>
<p><code>$ git add [dir]</code></p>
</li>
<li><p>添加当前目录的所有文件到暂存区</p>
<p><code>$ git add .</code></p>
</li>
<li><p>添加每个变化前，都会要求确认,对于同一个文件的多处变化，可以实现分次提交</p>
<p><code>$ git add -p</code></p>
</li>
<li><p>删除工作区文件，并且将这次删除放入暂存区</p>
<p><code>$ git rm [file1][file2] …</code></p>
</li>
<li><p>停止追踪指定文件，但该文件会保留在工作区</p>
<p><code>$ git rm --cached [file]</code></p>
</li>
<li><p>改名文件，并且将这个改名放入暂存区</p>
<p><code>$ git mv [file-original][file-renamed]</code></p>
</li>
</ul>
        
        
        <p class="article-more-link">
          
            <a href="/2016/12/08/git命令使用大全/#more">阅读全文</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/git/">git</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/12/08/git命令使用大全/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/12/08/git命令使用大全/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/05/微信SDK使用时遇到的问题汇总/" title="使用微信SDK遇到的问题汇总" itemprop="url">使用微信SDK遇到的问题汇总</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kevin" target="_blank" itemprop="author">Kevin</a>
		
  <p class="article-time">
    <time datetime="2016-12-05T10:12:00.000Z" itemprop="datePublished"> 发表于 2016-12-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在正式开始之前这里要着啰嗦一下，进来的同学一定要看，在申请应用的时候要填一个签名，这个签名是由应用的签名文件keystore决定的，那么你在填这个签名的时候，一定要把你的应用用正式的keyStore生成apk，安装到手机，然后用微信提供的获取应用签名的apk工具获取你应用的签名，然后这会生成的这个签名才是正确的，千万记得，不要使用dubug的ketStore测试，不然后面虽然可以修改，修改了后要审核，但是审核也是需要时间的，会很麻烦。<br>还有一点，你在测试微信分享的时候可能会直接在Eclipse好或者Studio运行项目，那样使用的肯定是dubug的keyStore了，这样分享的时候会被微信拒绝，微信会生成缓存，就算你这会换了正式的keystore来分享显示的还会是被微信拒绝，就算重启微信重启手机也不管用，那你就要清空微信的数据了；很多东西是不是丢了？好吧，啰嗦够了，正式进入主题。</p>
<p>今天会提供如果实现微信分享，并且对怎么成功接受回调结果做一个详细的介绍和教程，有回调结果失败的同学，往下看吧</p>
        
        
        <p class="article-more-link">
          
            <a href="/2016/12/05/微信SDK使用时遇到的问题汇总/#more">阅读全文</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/12/05/微信SDK使用时遇到的问题汇总/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/12/05/微信SDK使用时遇到的问题汇总/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/05/mac_library_show_hide/" title="解决git status/commit时中文文件名乱码" itemprop="url">解决git status/commit时中文文件名乱码</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kevin" target="_blank" itemprop="author">Kevin</a>
		
  <p class="article-time">
    <time datetime="2016-12-05T10:12:00.000Z" itemprop="datePublished"> 发表于 2016-12-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>#不对0x80以上的字符进行quote，解决git status/commit时中文文件名乱码</p>
<p><code>git config --global core.quotepath false</code></p>
<p><a href="http://xstarcd.github.io/wiki/shell/git_chinese.html" target="_blank" rel="external">http://xstarcd.github.io/wiki/shell/git_chinese.html</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/git/">git</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/git/">git</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/12/05/mac_library_show_hide/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/12/05/mac_library_show_hide/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/05/图标尺寸/" title="图标尺寸" itemprop="url">图标尺寸</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kevin" target="_blank" itemprop="author">Kevin</a>
		
  <p class="article-time">
    <time datetime="2016-12-05T10:12:00.000Z" itemprop="datePublished"> 发表于 2016-12-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="Pixel-Densities"><a href="#Pixel-Densities" class="headerlink" title="Pixel Densities"></a>Pixel Densities</h2><p>Android icons require five separate sizes for different screen pixel densities. Icons for lower resolution are created automatically from the baseline.</p>
        
        
        <p class="article-more-link">
          
            <a href="/2016/12/05/图标尺寸/#more">阅读全文</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/size/">size</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/12/05/图标尺寸/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/12/05/图标尺寸/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/05/Android最佳实践/" title="Android最佳实践" itemprop="url">Android最佳实践</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kevin" target="_blank" itemprop="author">Kevin</a>
		
  <p class="article-time">
    <time datetime="2016-12-05T10:12:00.000Z" itemprop="datePublished"> 发表于 2016-12-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <ol>
<li>定义变量时，UI变量单独放一块，数据变量放一块，空行隔开不要掺杂在一块。</li>
<li><p>使用UIL时，如果只是简单加载一个图片的bitmap，可以使用SimpleImageLoadingListener方法，而不是ImageLoadingListener。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">imageLoader.displayImage(detailModel.getData().getPicture(), </div><div class="line">                        headerBg, </div><div class="line">                        new SimpleImageLoadingListener() &#123;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) &#123;</div><div class="line">                        headerBg.setImageBitmap(loadedImage);</div><div class="line">                        setBitmap(loadedImage);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>Activity或Fragment中对adapter.updateDataSet(data);时，<code>notifyDataSetChanged</code>的操作放在adapter的updateDataSet方法内执行。</p>
        
        
        <p class="article-more-link">
          
            <a href="/2016/12/05/Android最佳实践/#more">阅读全文</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/12/05/Android最佳实践/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/12/05/Android最佳实践/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/05/处理表情和文字输入的正确姿势/" title="处理表情和文字输入的正确姿势" itemprop="url">处理表情和文字输入的正确姿势</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kevin" target="_blank" itemprop="author">Kevin</a>
		
  <p class="article-time">
    <time datetime="2016-12-05T10:12:00.000Z" itemprop="datePublished"> 发表于 2016-12-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <ol>
<li>点击“输入框”以外的区域，如果当前他们显示的话，需要隐藏表情面板或者软键盘。</li>
<li>点击“输入框”，如果当前表情面板显示的话，需要先隐藏之，然后弹出软键盘。</li>
<li>输入框中一般会有显示当前输入状态的提示按钮（有的在输入框左边，有的在右边），比如，如果当前是表情输入状态，该提示按钮的图标应该是软键盘，以提示用户点击该按钮切换到文字输入状态。这个提示按钮的图标和点击后的响应要分情况处理，是动态的。</li>
<li><p>键盘相关操作方法</p>
        
        
        <p class="article-more-link">
          
            <a href="/2016/12/05/处理表情和文字输入的正确姿势/#more">阅读全文</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/12/05/处理表情和文字输入的正确姿势/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/12/05/处理表情和文字输入的正确姿势/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/05/Android机型适配之痛/" title="Android机型适配之痛" itemprop="url">Android机型适配之痛</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kevin" target="_blank" itemprop="author">Kevin</a>
		
  <p class="article-time">
    <time datetime="2016-12-05T10:12:00.000Z" itemprop="datePublished"> 发表于 2016-12-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Android项目中Camera的适配。</p>
        
        
        <p class="article-more-link">
          
            <a href="/2016/12/05/Android机型适配之痛/#more">阅读全文</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/12/05/Android机型适配之痛/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/12/05/Android机型适配之痛/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/05/开发规范/" title="开发规范" itemprop="url">开发规范</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kevin" target="_blank" itemprop="author">Kevin</a>
		
  <p class="article-time">
    <time datetime="2016-12-05T10:12:00.000Z" itemprop="datePublished"> 发表于 2016-12-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Android 开发中类、方法、变量、资源等命名规则。</p>
        
        
        <p class="article-more-link">
          
            <a href="/2016/12/05/开发规范/#more">阅读全文</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/12/05/开发规范/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/12/05/开发规范/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/05/基于Travis-CI搭建Android自动打包发布工作流/" title="基于Travis-CI搭建Android自动打包发布工作流" itemprop="url">基于Travis-CI搭建Android自动打包发布工作流</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kevin" target="_blank" itemprop="author">Kevin</a>
		
  <p class="article-time">
    <time datetime="2016-12-05T10:12:00.000Z" itemprop="datePublished"> 发表于 2016-12-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>未自动化前安卓开发总是避免不了这样的工作流程：</p>
<ol>
<li>开发一些新功能，提交代码</li>
<li>完成一部分功能后，打包一个测试版APK</li>
<li>将测试版APK上传到QQ群 / 网盘 / Fir.im / 蒲公英等</li>
<li>在QQ群或发布平台解释当前版本所完成的功能</li>
<li>通知测试人员测试</li>
</ol>
<p>实现了这套自动化发布后，工作流程被简化成：</p>
<ol>
<li>开发新功能，提交代码</li>
<li>通过git tag对代码打一个内测版的tag，</li>
</ol>
<p>Tag提交后Travis CI会自动编译代码，生成APK文件并分发到Github和fir.im，Github和fir.im中会保持Tag的描述信息，分发完成后会有邮件通知所有参与测试的人员。而作为开发人员，只需要专注于对代码打好一个Tag就可以了。</p>
<p>整个流程看似做了不少工作，其实体现在Travis CI只有数行指令而已，以下逐一讲解：</p>
        
        
        <p class="article-more-link">
          
            <a href="/2016/12/05/基于Travis-CI搭建Android自动打包发布工作流/#more">阅读全文</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Travis-CI/">Travis-CI</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/12/05/基于Travis-CI搭建Android自动打包发布工作流/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/12/05/基于Travis-CI搭建Android自动打包发布工作流/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/02/获取屏幕原始高度(工作中遇到的问题)/" title="获取屏幕原始高度" itemprop="url">获取屏幕原始高度</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kevin" target="_blank" itemprop="author">Kevin</a>
		
  <p class="article-time">
    <time datetime="2016-12-02T08:39:19.000Z" itemprop="datePublished"> 发表于 2016-12-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>android带有虚拟键的手机， 获取屏幕宽度默认不包含虚拟键的高度，以下代码是获取屏幕原始高度。</p>
        
        
        <p class="article-more-link">
          
            <a href="/2016/12/02/获取屏幕原始高度(工作中遇到的问题)/#more">阅读全文</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/12/02/获取屏幕原始高度(工作中遇到的问题)/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/12/02/获取屏幕原始高度(工作中遇到的问题)/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/11/28/mac_library_show_hide/" title="Mac 中显示资源库（Library）文件夹目录的几种方法" itemprop="url">Mac 中显示资源库（Library）文件夹目录的几种方法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kevin" target="_blank" itemprop="author">Kevin</a>
		
  <p class="article-time">
    <time datetime="2016-11-28T09:02:10.000Z" itemprop="datePublished"> 发表于 2016-11-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Mac中Library目录在10.6.7系统之后默认隐藏的，要想找到此文件夹有如下几种方法：</p>
<ul>
<li>用命令可以使其显示**</li>
</ul>
<blockquote>
<p>在终端中执行命令：</p>
<p>chflags nohidden ~/Library</p>
<p>可显示资源库文件夹</p>
<p>如想隐藏，可以在终端中执行命令：</p>
<p>chflags hidden ~/Library  </p>
</blockquote>
        
        
        <p class="article-more-link">
          
            <a href="/2016/11/28/mac_library_show_hide/#more">阅读全文</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/mac/">mac</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Mac/">Mac</a><a href="/tags/Library/">Library</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/11/28/mac_library_show_hide/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/11/28/mac_library_show_hide/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/11/24/TimerTask更新UI线程/" title="TimerTask更新UI" itemprop="url">TimerTask更新UI</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kevin" target="_blank" itemprop="author">Kevin</a>
		
  <p class="article-time">
    <time datetime="2016-11-24T02:41:59.000Z" itemprop="datePublished"> 发表于 2016-11-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>昨天犯了一个低级的错误，在TimerTask任务里执行activity跳转，导致activity切入动画无效。查阅相关资料，有以下两种方法更新UI</p>
        
        
        <p class="article-more-link">
          
            <a href="/2016/11/24/TimerTask更新UI线程/#more">阅读全文</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/TimerTask/">TimerTask</a><a href="/tags/Timer/">Timer</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/11/24/TimerTask更新UI线程/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/11/24/TimerTask更新UI线程/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/11/22/spannable/" title="Spannable的用法" itemprop="url">Spannable的用法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Kevin" target="_blank" itemprop="author">Kevin</a>
		
  <p class="article-time">
    <time datetime="2016-11-22T03:17:33.000Z" itemprop="datePublished"> 发表于 2016-11-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Spannable继承自Spanned接口，而实际上，Spanned继承自CharSequence接口。<br>在TextView的<code>setText(CharSequence text)</code>方法中，要求的参数正好是一个CharSequence对象，因此，我们可以通过Spannable对象来直接使用setText来完成文本的设置。在使用中通常使用<code>Spannable spn = new SpannableString(&quot;字符串&quot;)</code>;或者通过SpannableStringBuilder对象来进行构建。<br>在构建除了Spannable对象以后，就可以使用<code>spannable.setSpan(Obj what, int start, int end, int flags)</code>方法来进行样式的设置了，其中参数what是具体样式的实现对象，start则是该样式开始的位置，end对应的是样式结束的位置，参数flags，定义在Spannable中的常量，常用的有：</p>
        
        
        <p class="article-more-link">
          
            <a href="/2016/11/22/spannable/#more">阅读全文</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Spannable/">Spannable</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/11/22/spannable/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/11/22/spannable/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="carrie1217" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Android/" title="Android">Android<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/git/" title="git">git<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/mac/" title="mac">mac<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Mac/" title="Mac">Mac<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Library/" title="Library">Library<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Spannable/" title="Spannable">Spannable<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/TimerTask/" title="TimerTask">TimerTask<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Timer/" title="Timer">Timer<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/size/" title="size">size<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Travis-CI/" title="Travis-CI">Travis-CI<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 活着就要学习，学习不是为了活着。 <br/>
			情况是在不断的变化，要使自己的思想适应新的情况，就得学习。</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/carrie1217" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="Kevin">Kevin</a>
		
		
		</p>
		<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','DBjSFU5kGEcv8E-m-m_m','2.0.0');
</script>
</div></footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
